# State Mutability

Solidity 함수는 상태(State)를 다루는 방식에 따라 **상태 변경 여부와 이더 수신 가능 여부**를 명시적으로 지정할 수 있다.

이를 통해 코드의 의도를 명확히 하고, 불필요한 가스 비용을 절약하며, 보안 사고를 방지할 수 있다.

Solidity에서 대표적으로 쓰이는 state mutability 키워드는 `view`, `pure`, `payable`이다.

---

## 1. `view`

- **상태 변수 읽기만 가능**하다
- 상태를 수정하지 않는다는 것을 보장한다
- 컴파일러가 함수 내부에서 상태 변경이 없는지 검사한다

```solidity
function viewFunction() public view returns (uint256) {
    return myStateVar;
}
```

### 특징

- 상태 변수 읽기(O)
- 상태 변수 쓰기(X)
- 블록 정보(`block.timestamp` 등) 접근(O)

---

## 2. `pure`

- **상태를 읽지도 쓰지도 않는 함수**
- 입력값과 함수 내부의 연산만으로 결과를 반환한다

```solidity
function pureFunction(uint256 a, uint256 b) public pure returns (uint256) {
    return a + b;
}
```

### 특징

- 상태 변수 읽기(X)
- 상태 변수 쓰기(X)
- 블록·트랜잭션 관련 전역 변수 접근(X)

즉, 외부 환경과 완전히 독립적인 “순수 수학 함수”라고 볼 수 있다

---

## 3. `payable`

- **이더를 전송 받을 수 있는 함수**를 의미한다
- 선언하지 않으면, 함수에 이더를 보낼 경우 트랜잭션이 실패한다

```solidity
function deposit() public payable {
    // msg.value 를 통해 전송된 이더 값 확인 가능
}
```

### 특징

- 상태 변경 여부와는 별개로, 이더 수신 가능성을 나타낸다
- `payable` 키워드가 없는 함수는 이더를 받을 수 없다

---

## 가스비 비교

### 외부 호출 (External Call)

- 사용자가 **직접** `view` 또는 `pure` 함수를 호출할 때
- 트랜잭션이 발생하지 않고 로컬 노드에서 처리된다
- 블록체인에 기록되지 않으므로 **가스비가 발생하지 않는다**

### 내부 호출 (Internal Call)

- 컨트랙트 내부에서 `view`/`pure` 함수를 호출할 때
- 실제로 EVM이 실행되므로 연산 비용이 발생한다
- `view` : 상태 변수를 읽는 경우 **스토리지 접근 비용(SLOAD)** + 연산 비용 발생
- `pure` : 상태를 읽지 않으므로 **연산 비용만 발생**

### 요약

- 외부 호출: 가스비 없음 (`view`, `pure`)
- 내부 호출: `view`는 스토리지 접근 비용 발생, `pure`는 연산 비용만 발생

---

## 예제 코드

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract ViewAndPure {
    uint256 public x = 1; // 상태 변수

    // 상태를 읽기만 하는 함수
    function addToX(uint256 y) public view returns (uint256) {
        return x + y;
    }

    // 상태를 읽거나 변경하지 않는 함수
    function add(uint256 i, uint256 j) public pure returns (uint256) {
        return i + j;
    }

    // 이더를 받을 수 있는 함수
    function deposit() public payable {}
}
```

---

## 코드 해설

이 예제는 view와 pure 함수의 사용법을 보여주는 간단한 스마트 계약이다. 두 가지 함수 모두 상태를 변경하지 않으며, 각기 다른 방식으로 상태와 상호작용하지 않음을 보장한다.

**상태변수**

- `uint256 public x = 1;`
    - x는 상태 변수로, 스마트 계약의 storage에 저장된다.
    - public 키워드를 사용하여 이 변수는 외부에서 읽을 수 있다.
    - 초기 값은 1

**view** 함수 : **addToX**

- `function addToX(uint256 y) public view returns (uint256)`
    - 하나의 uint256 타입의 인자를 `y`로서 입력받는다.
    - `view` 키워드는 이 함수가 상태 변수를 읽을 수 있지만, 변경할 수 없음을 보장.
    - 상태변수 `x`의 값과 입력받은 값 `y`를 더한 결과를 반환
    - ex) `addToX(5)` 는 `x`은 `1`, `y`은 `5`이므로 `1 + 5 = 6`을 반환

**pure** 함수 : **add**

- `function add(uint256 i, uint256 j) public pure returns (uint256)`
    - 하나의 uint256 타입의 인자를 `i`와 `j`를 입력받는다.
    - `pure` 키워드는 이 함수가 상태 변수를 읽거나 변경하지 않음을 보장
    - 함수는 입력받은 두 값 `i`와 `j`를 더한 결과를 반환
    - ex) `add(3,4)` 는 `i`은 `3`, `j`은 `4`이므로 `3 + 4 = 7`을 반환

---

## 주의사항

- `view` 함수에서 상태를 변경하려 하면 컴파일 오류가 발생한다
- `pure` 함수에서 상태 변수나 블록 정보에 접근하려 하면 오류가 발생한다
- 외부에서 `view`/`pure` 함수를 호출할 때는 무료이지만,
    
    트랜잭션 안에서 내부 호출되면 가스비가 든다
    
- `payable` 키워드가 없으면 어떤 함수에도 이더를 전송할 수 없다