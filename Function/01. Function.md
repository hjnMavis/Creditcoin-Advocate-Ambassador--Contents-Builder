# Solidity 함수 구조

Solidity에서 함수(Function)는 계약(Contract)의 동작을 정의하는 기본 단위다.

함수는 입력값을 받아 로직을 실행하고, 상태를 변경하거나 값을 반환할 수 있다.

![함수 기본 구조](../image/functionStructure.png)

---

## 1. `functionName`

- **함수의 이름**을 정의한다 (필수)
- 이름은 고유해야 한다. 단, **함수 오버로딩(Overloading)** 을 통해 매개변수 타입이 다르면 같은 이름을 사용할 수 있다

```solidity
function transfer(address to, uint amount) public {}
function transfer(address to) public {}
```

---

## 2. Function Parameters

- **함수 입력값**을 정의한다 (선택)
- `<타입> <변수명>` 쌍으로 정의하며, 여러 개를 쉼표(,)로 구분한다

### 참고

- **데이터 위치 지정자** : `storage`, `memory`, `calldata` 를 매개변수에 붙일 수 있다
- **제한** : `mapping`은 매개변수나 반환값으로 직접 사용할 수 없다. `struct`는 가능하지만 경우에 따라 필드를 나눠 쓰는 게 더 적절하다

```solidity
function setValue(uint256 x, string memory name) public {}
```

---

## 3. Visibility

함수의 **접근 범위**를 결정한다. (반필수)

기본값은 `public`이다

- `public` : 누구나 호출 가능 (내부·외부 모두)
- `private` : 동일 계약 내부에서만 호출 가능
- `internal` : 동일 계약 또는 상속받은 계약에서만 호출 가능
- `external` : 계약 외부에서만 호출 가능 (내부에서는 `this` 키워드를 사용해야 호출 가능)

```solidity
function onlyInternal() internal {}
function onlyExternal() external {}
```

---

## 4. Modifier

- **함수 실행 전/후에 특정 조건을 검사하거나 실행 로직을 추가**하는 수식어다
- 여러 개를 붙일 수 있으며, 띄어쓰기로 구분한다

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}

function changeOwner(address newOwner) public onlyOwner {
    owner = newOwner;
}
```

---

## 5. `virtual` / `override`

상속 관계에서 함수 재정의를 제어한다

- `virtual` : 함수가 상속받는 계약에서 **오버라이드 가능**함을 의미한다
- `override` : 부모 계약의 함수를 **재정의**함을 명시한다

```solidity
contract A {
    function foo() public virtual returns (string memory) {
        return "A";
    }
}

contract B is A {
    function foo() public override returns (string memory) {
        return "B";
    }
}
```

---

## 6. State Mutability

- 함수가 **상태 변수(State Variable)를 변경하거나 읽을 수 있는지**, 이더를 받을 수 있는지 정의한다
- `view` : 상태를 읽기만 가능 (쓰기 불가)
- `pure` : 상태 읽기/쓰기 모두 불가 (순수 계산만)
- `payable` : 함수 호출 시 이더를 전송 받을 수 있음

```solidity
function readValue() public view returns (uint) { return num; }
function calculate(uint x, uint y) public pure returns (uint) { return x + y; }
function deposit() public payable {}
```

---

## 7. Return Variables

- 함수의 반환값 타입을 정의한다
- 여러 개를 반환할 수 있으며, 쉼표로 구분한다

```solidity
function getData() public pure returns (uint, bool) {
    return (123, true);
}
```

---

# 함수 예제 코드와 설명

### returnMany

```solidity
function returnMany() public pure returns (uint256, bool, uint256) {
    return (1, true, 2);
}
```

- 여러 값을 튜플로 반환한다

---

### named

```solidity
function named() public pure returns (uint256 x, bool b, uint256 y) {
    return (1, true, 2);
}
```

- 반환값에 이름을 지정할 수 있다
- 가독성이 좋아지고, 외부에서 반환값을 구조적으로 다룰 때 유용하다

---

### assigned

```solidity
function assigned() public pure returns (uint256 x, bool b, uint256 y) {
    x = 1;
    b = true;
    y = 2;
}
```

- 반환값 변수에 직접 값을 할당하면 `return` 문을 생략할 수 있다

---

### destructuringAssignments

```solidity
function destructuringAssignments()
    public
    pure
    returns (uint256, bool, uint256, uint256, uint256)
{
    (uint256 i, bool b, uint256 j) = returnMany();
    // 특정 값은 생략할 수 있다
    (uint256 x,, uint256 y) = (4, 5, 6);
    return (i, b, j, x, y);
}
```

- 다른 함수의 반환값을 **구조 분해 할당(destructuring)** 할 수 있다
- 필요 없는 값은 `, ,` 처럼 건너뛸 수 있다

---

### arrayInput

```solidity
function arrayInput(uint256[] memory _arr) public {}
```

- 배열을 입력 매개변수로 받을 수 있다
- 동적 배열을 받을 때는 반드시 `memory`나 `calldata`를 명시해야 한다

---

### arrayOutput

```solidity
uint256[] public arr;

function arrayOutput() public view returns (uint256[] memory) {
    return arr;
}
```

- 배열 전체를 반환할 수 있다
- 반환 타입에 `memory`를 붙여야 한다

---

### someFuncWithManyInputs

```solidity
function someFuncWithManyInputs(
    uint256 x,
    uint256 y,
    uint256 z,
    address a,
    bool b,
    string memory c
) public pure returns (uint256) {}
```

### 호출 방식 1 (순서 기반)

```solidity
function callFunc() external pure returns (uint256) {
    return someFuncWithManyInputs(1, 2, 3, address(0), true, "c");
}
```

### 호출 방식 2 (키-값 기반)

```solidity
function callFuncWithKeyValue() external pure returns (uint256) {
    return someFuncWithManyInputs({
        a: address(0),
        b: true,
        c: "c",
        x: 1,
        y: 2,
        z: 3
    });
}
```

- 인자가 많을 경우 **순서 기반** 호출은 가독성이 떨어진다
- **키-값 기반 호출**을 사용하면 어떤 값이 어떤 매개변수에 들어가는지 명확하게 알 수 있다

---

# 정리

- 함수 정의는 `function <이름>(입력) <가시성> <제한자> <mutability> returns (출력)` 형태로 구성된다
- `visibility`, `state mutability`, `modifier`는 코드 안전성과 가독성을 위해 반드시 고려해야 한다
- 여러 값 반환, 구조 분해 할당, 키-값 기반 인자 전달 등 Solidity 함수는 유연한 문법을 제공한다
