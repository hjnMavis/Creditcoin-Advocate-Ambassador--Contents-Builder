# ABI (Application Binary Interface)

## 개념

ABI는 스마트 컨트랙트와 외부 애플리케이션(혹은 다른 스마트 컨트랙트) 간의 **상호작용을 위한 표준화된 인터페이스**다

Solidity로 작성된 스마트 컨트랙트는 사람이 이해하기 쉬운 고수준 언어지만, EVM(Ethereum Virtual Machine)은 **바이너리 코드만 이해**할 수 있다

ABI는 이 둘 사이에서 **브리지 역할**을 한다

- 함수 호출 → 사람이 쓴 명령을 **바이너리 데이터로 인코딩**해 EVM에 전달한다
- 함수 반환값 → EVM이 돌려주는 바이너리 데이터를 **사람이 읽을 수 있는 값으로 디코딩**한다

즉, ABI는 **컨트랙트와 외부 세계를 연결하는 약속된 규칙**이라고 볼 수 있다

---

## 주요 역할

1. **데이터 인코딩**
    
    함수 호출 시 필요한 매개변수를 바이너리 형식으로 변환한다
    
2. **데이터 디코딩**
    
    함수 호출 결과를 사람이 이해할 수 있는 데이터로 변환한다
    
3. **함수 식별자(Function Selector) 생성**
    
    호출하려는 함수의 이름과 매개변수 타입을 해시 처리하여 고유 식별자(4바이트)를 만든다
    
    이 식별자를 통해 EVM은 정확히 어떤 함수를 실행해야 하는지 알 수 있다
    

---

## ABI 구조

- **Function Selector**
    
    함수 이름과 매개변수 타입을 Keccak-256 해시 후 상위 4바이트를 추출한 값이다
    
    Solidity에서는 `.selector` 속성을 사용해 쉽게 확인할 수 있다
    
- **Encoded Arguments**
    
    함수 호출 시 전달할 매개변수들을 바이너리로 인코딩한 데이터다
    

함수 호출 데이터는 **Function Selector + Encoded Arguments**로 구성된다

---

## 인코딩 예제 코드

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address, uint) external;
}

contract Token {
    function transfer(address, uint) external {}
}

// AbiEncode Contract
contract AbiEncode {
    function test(address _contract, bytes calldata data) external {
        (bool ok, ) = _contract.call(data);
        require(ok, "call failed");
    }

    function encodeWithSignature(
        address to,
        uint amount
    ) external pure returns (bytes memory) {
        return abi.encodeWithSignature("transfer(address,uint256)", to, amount);
    }

    function encodeWithSelector(
        address to,
        uint amount
    ) external pure returns (bytes memory) {
        return abi.encodeWithSelector(IERC20.transfer.selector, to, amount);
    }

    function encodeCall(address to, uint amount) external pure returns (bytes memory) {
        return abi.encodeCall(IERC20.transfer, (to, amount));
    }
}

```

---

## 함수별 해설

### test 함수

```solidity
function test(address _contract, bytes calldata data) external {
    (bool ok, ) = _contract.call(data);
    require(ok, "call failed");
}

```

- `_contract`: 호출 대상 스마트 컨트랙트 주소
- `data`: ABI로 인코딩된 함수 호출 데이터
- `call`: 저수준 호출(Low-level call)로 직접 바이너리 데이터를 전달한다
- `require(ok, "call failed")`: 호출 실패 시 트랜잭션을 되돌린다

---

### encodeWithSignature 함수

```solidity
function encodeWithSignature(
    address to,
    uint amount
) external pure returns (bytes memory) {
    return abi.encodeWithSignature("transfer(address,uint256)", to, amount);
}

```

- `"transfer(address,uint256)"`: 호출하려는 함수 이름과 매개변수 타입을 문자열로 지정한다
- `to`: 수신자 주소
- `amount`: 전송 금액
- `abi.encodeWithSignature`: 함수 이름 + 인자 값을 인코딩해 바이트 데이터로 반환한다

---

### encodeWithSelector 함수

```solidity
function encodeWithSelector(
    address to,
    uint amount
) external pure returns (bytes memory) {
    return abi.encodeWithSelector(IERC20.transfer.selector, to, amount);
}

```

- `IERC20.transfer.selector`: `transfer(address,uint256)` 함수의 4바이트 selector
- `abi.encodeWithSelector`: 함수 selector + 인자를 인코딩한다
- 인터페이스를 통해 안전하게 selector를 가져올 수 있다

---

### encodeCall 함수

```solidity
function encodeCall(address to, uint amount) external pure returns (bytes memory) {
    return abi.encodeCall(IERC20.transfer, (to, amount));
}

```

- `IERC20.transfer`: 호출할 함수 자체를 지정한다
- `(to, amount)`: 인자를 튜플 형식으로 전달한다
- `abi.encodeCall`: 함수와 매개변수를 결합해 간결하게 ABI 데이터를 생성한다
- 최신 Solidity 문법으로 가독성이 좋고 오류 가능성이 낮다

---

## 인코딩 방식 정리

- `call` → 가장 저수준, 인코딩된 바이트 데이터를 직접 전달
- `encodeWithSignature` → 함수 이름을 문자열로 직접 지정
- `encodeWithSelector` → 함수 selector(4바이트)와 인자 전달
- `encodeCall` → 함수 정의와 인자를 함께 지정, 가장 안전하고 권장되는 방식

---

## 디코딩 예제 코드

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// AbiDecode Contract
contract AbiDecode {
    struct MyStruct {
        string name;
        uint[2] nums;
    }

    function encode(
        uint x,
        address addr,
        uint[] calldata arr,
        MyStruct calldata myStruct
    ) external pure returns (bytes memory) {
        return abi.encode(x, addr, arr, myStruct);
    }

    function decode(
        bytes calldata data
    )
        external
        pure
        returns (uint x, address addr, uint[] memory arr, MyStruct memory myStruct)
    {
        (x, addr, arr, myStruct) = abi.decode(data, (uint, address, uint[], MyStruct));
    }
}

```

---

## encode 함수

```solidity
function encode(
    uint x,
    address addr,
    uint[] calldata arr,
    MyStruct calldata myStruct
) external pure returns (bytes memory) {
    return abi.encode(x, addr, arr, myStruct);
}

```

- `abi.encode`: 여러 타입의 데이터를 바이트 배열로 인코딩한다
- 다양한 자료형을 묶어서 하나의 바이트 배열로 표현할 수 있다

---

## decode 함수

```solidity
function decode(
    bytes calldata data
)
    external
    pure
    returns (uint x, address addr, uint[] memory arr, MyStruct memory myStruct)
{
    (x, addr, arr, myStruct) = abi.decode(data, (uint, address, uint[], MyStruct));
}

```

- `abi.decode`: 바이트 데이터를 지정된 타입으로 복원한다
- 두 번째 인수는 반드시 인코딩 시 사용한 타입과 동일해야 한다
- 매개변수 `data`를 받아 원래 형태의 값들로 되돌린다

---

## 정리

- ABI는 **컨트랙트와 외부 세계의 약속된 언어**다
- 인코딩(encode)은 사람이 이해하는 입력값 → EVM이 이해하는 바이트 데이터
- 디코딩(decode)은 EVM의 바이트 데이터 → 사람이 이해할 수 있는 값
- ABI를 통해 컨트랙트 간 호출, DApp과 컨트랙트 상호작용이 가능하다

---

![ABI](../image/abi.png)