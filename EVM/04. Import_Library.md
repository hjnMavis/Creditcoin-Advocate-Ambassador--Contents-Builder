# Import

## 개념

Solidity에서 `import` 키워드는 코드를 **모듈화**하고 **재사용**할 수 있도록 도와준다

큰 프로젝트를 관리할 때 파일을 여러 개로 나누어 작성하는 것이 일반적이다.

`import`를 사용하면 다른 파일에 정의된 구조체, 함수, 계약(Contract) 등을 불러와 사용할 수 있다

- **로컬 파일 임포트** : 같은 프로젝트 내 파일을 불러온다
- **외부 파일 임포트** : GitHub 같은 외부 저장소에서 불러온다

---

## 로컬 파일 임포트

### 프로젝트 구조 예시

```bash
├── Import.sol
└── Foo.sol
```

### Foo.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

struct Point {
    uint256 x;
    uint256 y;
}

error Unauthorized(address caller);

function add(uint256 x, uint256 y) pure returns (uint256) {
    return x + y;
}

contract Foo {
    string public name = "Foo";
}

```

### Import.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Foo.sol 파일 전체를 임포트
import "./Foo.sol";

// 특정 심볼만 임포트하며 별칭(alias)을 사용
import {Unauthorized, add as func, Point} from "./Foo.sol";

contract Import {
    Foo public foo = new Foo();

    function getFooName() public view returns (string memory) {
        return foo.name();
    }
}

```

### 해설

- `import "./Foo.sol";` : Foo.sol에 정의된 모든 코드(`struct`, `function`, `contract`)를 불러온다
- `import {Unauthorized, add as func, Point} from "./Foo.sol";` : 특정 심볼만 불러오고, `add` 함수를 `func`라는 이름으로 사용한다
- 별칭(alias)은 동일한 이름 충돌을 피하거나, 더 직관적인 이름을 주고 싶을 때 유용하다

---

## 외부 파일 임포트

Solidity는 인터넷 경로를 통한 **원격 임포트**를 지원한다

공개된 라이브러리를 쉽게 재사용할 수 있어 개발 효율이 크게 향상된다

```solidity
// GitHub 저장소의 특정 파일 임포트
import "https://github.com/owner/repo/blob/branch/path/to/Contract.sol";

// OpenZeppelin 라이브러리 예시
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol";
```

### 해설

- 주로 **OpenZeppelin** 같은 보안 검증된 표준 라이브러리를 임포트한다
- 보통 로컬 개발 환경에서는 직접 GitHub 경로를 쓰기보다는 **npm 패키지 설치 후 node_modules 경로를 import** 하는 방식을 권장한다
- 예:
    
    ```solidity
    import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    ```
    

---

# Library

## 개념

`library`는 반복적으로 사용되는 로직을 모듈화해 재사용할 수 있는 코드 구조다

코드를 깔끔하게 관리할 수 있고, 동일한 기능을 여러 계약에서 공유하므로 **가스 비용 절약** 효과도 있다

---

## Library 특징

- **상태 변수 없음** : Storage를 직접 가질 수 없다
- **Ether 전송 불가** : `payable` 함수 불가
- **순수 연산 모듈화** : `pure` 또는 `view` 함수가 많다
- **재사용성** : 다양한 계약에서 동일 로직을 가져다 쓸 수 있다

---

## Library 종류

1. **Embedded Library**
    - `internal` 함수만 있으면 라이브러리가 별도로 배포되지 않고, 해당 코드를 사용하는 계약에 그대로 포함된다
2. **Linked Library**
    - `public` 또는 `external` 함수가 있으면 라이브러리가 별도로 배포되고, 사용하는 계약에서 참조하도록 링크된다

### Library 구조
![library](../image/library.png)

* Library는 library 키워드를 사용하여 선언한다.
* Library 내부에는 `internal`, `public`, `external`함수가 포함될 수 있다.

### Library 사용
library를 사용하는 방법에는 두가지가 있다.
1. **직접호출** : Library의 함수를 일반적인 함수 호출 방식으로 직접 호출
2. **using for** : 특정 데이터 타입에 대해 Library 함수를 인스턴스 메서드처럼 사용 

```bash
├─ MathLibrary.sol
└─ MyContract.sol
```
```solidity
import "./MathLibrary.sol";


contract MyContract{
    // 직접 호출 사용
    function subtractNumbers(uint256 a, uint256 b) public pure returns (uint256){
        return Mathlibrary.subtract(a,b)
    }

    //using for 사용
    using MathLibrary for uint256;
    function addNumbers(uint256 a, uint256 b) public pure returns (uint256){
        return a.add(b);
    }
}
```
`using MathLibrary for uint256`
`MathLibrary`에 정의된 함수들을 `uint256` 타입에서 직접 호출할 수 있도록 연결한다는 의미. 
연결된 Library의 함수는 uint256 타입에 대해 인스턴스 메서드처럼 호출할 수 있게 된다. 
-> 특정 데이터 타입(uint256)을 확장하여 Library의 함수들을 마치 uint256 타입의 메서드처럼 사용할 수 있게 하는 것.

---

### Library 예제코드
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

library Math {
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
        // else z = 0 (default value)
    }
}

contract TestMath {
    function testSquareRoot(uint256 x) public pure returns (uint256) {
        return Math.sqrt(x);
    }
}

// index로 element를 제거하고 array를 재구성 하는 Array function
// elemnet 사이에 간격이 없도록 한다.
library Array {
    function remove(uint256[] storage arr, uint256 index) public {
        // 마지막 요소를 삭제할 위치로 이동
        require(arr.length > 0, "Can't remove from empty array");
        arr[index] = arr[arr.length - 1];
        arr.pop();
    }
}

contract TestArray {
    using Array for uint256[];

    uint256[] public arr;

    function testArrayRemove() public {
        for (uint256 i = 0; i < 3; i++) {
            arr.push(i);
        }

        arr.remove(1);

        assert(arr.length == 2);
        assert(arr[0] == 0);
        assert(arr[1] == 2);
    }
}
```

**`Math` library** : 숫자의 제곱근을 계산하는 `sqrt ` 함수를 포함하고 있다.    
**`TestMath` contract** : 직접 호출 방식 사용  
**`Array` library** : array에서 특정 index의 element를 제거하고, array의 gap을 채우기 위한 `remove` 함수 포함   
**`TestArray` contract** : using for (타입 확장) 사용

