# Factory Pattern

## 개념

Factory 패턴은 스마트 컨트랙트에서 **여러 개의 동일한 종류의 컨트랙트(인스턴스)** 를 효율적으로 생성하고 관리하기 위한 디자인 패턴이다.

Solidity에서는 **다른 컨트랙트를 생성하는 컨트랙트(Factory)** 를 만들 수 있으며, 이를 통해 코드가 모듈화되고 생성된 컨트랙트를 추적·관리하기가 쉬워진다.

---

## 특징과 장점

- **대량 배포** : 동일한 구조를 가진 컨트랙트를 여러 개 만들 수 있다
- **중앙 관리** : Factory 컨트랙트에서 생성된 모든 컨트랙트 주소를 추적·관리할 수 있다
- **유연성** : 생성 시점에 인자(예: 소유자 주소, 모델명, 초기 값)를 다르게 지정 가능하다
- **이더 전송 지원** : 생성하면서 이더를 함께 전달할 수도 있다

---

## 예제 코드

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Car {
    address public owner;
    string public model;
    address public carAddr;

    constructor(address _owner, string memory _model) payable {
        owner = _owner;
        model = _model;
        carAddr = address(this);
    }
}

contract CarFactory {
    Car[] public cars;

    // 단순 생성
    function create(address _owner, string memory _model) public {
        Car car = new Car(_owner, _model);
        cars.push(car);
    }

    // 생성 시 이더도 함께 전송
    function createAndSendEther(address _owner, string memory _model) public payable {
        Car car = (new Car){value: msg.value}(_owner, _model);
        cars.push(car);
    }

    // 생성된 Car 정보 조회
    function getCar(uint256 _index)
        public
        view
        returns (
            address owner,
            string memory model,
            address carAddr,
            uint256 balance
        )
    {
        Car car = cars[_index];
        return (car.owner(), car.model(), car.carAddr(), address(car).balance);
    }
}
```

---

## 함수별 해설

### 1. `create`

```solidity
function create(address _owner, string memory _model) public {
    Car car = new Car(_owner, _model);
    cars.push(car);
}
```

- 새로운 `Car` 컨트랙트를 생성한다
- 생성된 컨트랙트는 `cars` 배열에 저장해 관리한다
- 이때 생성자는 `Car`의 `constructor`를 실행하며, 소유자와 모델명을 초기화한다

---

### 2. `createAndSendEther`

```solidity
function createAndSendEther(address _owner, string memory _model) public payable {
    Car car = (new Car){value: msg.value}(_owner, _model);
    cars.push(car);
}
```

- 새로운 `Car` 컨트랙트를 생성하면서 이더를 함께 보낸다
- `msg.value`에 포함된 이더가 생성된 `Car` 컨트랙트의 잔액에 저장된다
- `(new Contract){value: amount}(args)` 문법은 **컨트랙트 생성 + 이더 전송**을 동시에 수행한다

---

### 3. `getCar`

```solidity
function getCar(uint256 _index)
    public
    view
    returns (
        address owner,
        string memory model,
        address carAddr,
        uint256 balance
    )
{
    Car car = cars[_index];
    return (car.owner(), car.model(), car.carAddr(), address(car).balance);
}
```

- `cars` 배열에서 특정 인덱스의 `Car` 컨트랙트를 가져온다
- 해당 `Car`의 소유자, 모델명, 주소, 잔액을 반환한다
- `address(car).balance`를 통해 생성된 컨트랙트의 잔액을 확인할 수 있다

---

## 실행 흐름 정리

1. `CarFactory` 배포 → Factory 역할 수행
2. `create` 함수 호출 → 새로운 `Car` 컨트랙트 생성
3. `createAndSendEther` 호출 → 새로운 `Car` 생성 + 이더 전송
4. `getCar(index)` → 생성된 `Car`의 정보 확인

---

## 확장 포인트

- **배열 대신 매핑 사용**
    
    특정 소유자 주소 기준으로 생성된 `Car`를 관리할 수 있다
    
    ```solidity
    mapping(address => Car[]) public carsByOwner;
    ```
    
- **이벤트 기록**
    
    컨트랙트 생성 시 `event`를 발생시켜 로그에서 쉽게 추적할 수 있다
    
    ```solidity
    event CarCreated(address indexed owner, address carAddr, string model);
    ```
    
- **Clone Factory 패턴**
    
    `new` 키워드 대신 **EIP-1167 Minimal Proxy(Clones)** 패턴을 사용하면
    
    훨씬 저렴한 가스 비용으로 동일한 컨트랙트를 대량 배포할 수 있다
    

---

## 요약

- Factory 패턴은 **다수의 동일한 컨트랙트를 생성·관리하는 패턴**이다
- Solidity에서는 `new` 키워드를 사용해 다른 컨트랙트를 생성할 수 있다
- 생성된 컨트랙트는 배열/매핑에 저장해 관리하고, 필요하면 이더도 전송할 수 있다
- 실무에서는 이벤트 로그, Proxy 패턴과 결합해 더 효율적으로 확장할 수 있다
