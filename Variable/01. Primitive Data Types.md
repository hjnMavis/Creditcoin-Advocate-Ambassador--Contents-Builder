# Primitive Data Types

## 개념

Solidity에서 **기본 데이터 타입(Primitive Data Types)** 은 가장 기초적인 값들을 표현한다

이 타입들은 모든 계약(Contract)의 기반을 이루며, 변수 선언 시 가장 자주 사용된다

대표적인 타입에는 `bool`, `uint`, `int`, `address`, `bytes` 등이 있다

**선언 방법**
![variable](../image/variable.png)

일반적인 선언 형식은 다음과 같다:

```solidity
<타입> <가시성> <변수명> = <값>;
```

---

## Boolean

- `bool` 타입은 **참(True) 또는 거짓(False)** 값을 가진다
- 조건문(`if`, `require`, `assert`) 등에서 사용된다

```solidity
bool public boo = true;
```

> 참고: public 가시성은 다른 계약이나 외부에서 이 값을 조회할 수 있게 한다.
> 

---

## Unsigned Integer (`uint`)

- `uint`는 **부호 없는 정수**로, 음수가 아닌 값(0 이상)만 표현한다
- 크기는 8비트 단위로 늘릴 수 있으며, 최대 `uint256` 까지 지원한다
- `uint`는 `uint256`의 별칭이다

### 크기와 범위

- `uint8` : 0 ~ 2^8 - 1 (0 ~ 255)
- `uint16` : 0 ~ 2^16 - 1 (0 ~ 65535)
- ...
- `uint256` : 0 ~ 2^256 - 1

```solidity
uint8 public u8 = 1;
uint256 public u256 = 456;
uint public u = 123; // uint == uint256
```

---

## Signed Integer (`int`)

- `int`는 **부호 있는 정수**로, 음수까지 표현할 수 있다
- 마찬가지로 8비트 단위로 크기를 지정할 수 있으며, 기본은 `int256`이다

### 크기와 범위

- `int8` : -2^7 ~ 2^7 - 1 (-128 ~ 127)
- `int16` : -2^15 ~ 2^15 - 1
- ...
- `int256` : -2^255 ~ 2^255 - 1

```solidity
int8 public i8 = -1;
int256 public i256 = 456;
int public i = -123; // int == int256
```

### 최소값과 최대값

```solidity
int256 public minInt = type(int256).min; // -2^255
int256 public maxInt = type(int256).max; // 2^255 - 1
```

---

## Address

- `address` 타입은 **이더리움 계정 주소**를 저장한다
- 크기는 **20바이트(160비트)**이며, 외부 계정(EOA) 또는 스마트 컨트랙트 주소를 담을 수 있다
- 주소 타입은 추가적으로 `address payable` 로 선언해 이더 전송(`transfer`, `send`, `call{value:}`)이 가능하다

```solidity
address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;
```

---

## Bytes

- Solidity에서 바이트 배열은 두 가지로 나뉜다
1. **고정 크기 바이트 배열 (`bytes1` ~ `bytes32`)**
    - 최대 32바이트까지 가능하다
    - 길이가 고정돼 있어 배열 길이를 별도로 저장하지 않는다
2. **동적 크기 바이트 배열 (`bytes`)**
    - `byte[]`의 축약형이다
    - 배열 길이를 포함해 저장되므로 크기가 유연하다

```solidity
bytes1 public a = 0xb5;         // 1바이트, 값: [10110101]
bytes public dynamicBytes = "Hi"; // "Hi"는 ASCII 값으로 저장됨
```

---

## 기본값 (Default Values)

초기화되지 않은 변수는 자동으로 기본값을 가진다

```solidity
bool public defaultBoo;       // false
uint256 public defaultUint;   // 0
int256 public defaultInt;     // 0
address public defaultAddr;   // 0x0000000000000000000000000000000000000000
bytes2 public defaultBytes2;  // 0x0000
bytes public defaultBytes;    // 빈 배열, 길이 0
```

---

## 예제 코드

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Primitives {
    // Boolean
    bool public boo = true;

    // Unsigned Integer
    uint8 public u8 = 1;
    uint256 public u256 = 456;
    uint public u = 123; // uint == uint256

    // Signed Integer
    int8 public i8 = -1;
    int256 public i256 = 456;
    int public i = -123; // int == int256

    // 최소값과 최대값
    int256 public minInt = type(int256).min;
    int256 public maxInt = type(int256).max;

    // Address
    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

    // Bytes
    bytes1 public a = 0xb5;
    bytes1 public b = 0x56;
    bytes public str = "Hello";

    // 기본값 (default values)
    bool public defaultBoo;       // false
    uint256 public defaultUint;   // 0
    int256 public defaultInt;     // 0
    address public defaultAddr;   // 0x000...000
    bytes2 public defaultBytes2;  // 0x0000
    bytes public defaultBytes;    // 빈 배열
}
```

---

## 주의사항 및 추가 포인트

- `uint`와 `int`는 **산술 연산 시 오버플로/언더플로 검증**이 Solidity 0.8.x부터 자동 적용된다 (이전 버전은 SafeMath 필요)
- `address`는 단순 저장 타입이고, 실제 이더 송금은 `address payable`로만 가능하다
- `bytes`와 `string`은 둘 다 동적 바이트 배열이지만, `string`은 UTF-8 인코딩 텍스트를 저장하기 위한 특수 타입이다
- 가스 비용 측면에서 **고정 크기 바이트 배열(bytes32)** 은 **동적 배열(bytes)** 보다 효율적이다



