# ERC-20 (Fungible Token)

## 개념

- **Fungible Token**: 서로 대체 가능한 동일 가치를 가진 디지털 자산
    - 실물 화폐와 유사하다. 예: 1달러 지폐 ↔ 다른 1달러 지폐
    - 모든 단위가 동일하기 때문에 개별 구분이 필요 없다
- **ERC-20**: 이더리움에서 Fungible Token을 구현하기 위한 **표준 프로토콜**
    - 최소한의 기능(전송, 잔액 조회, 권한 승인 등)을 정의
    - 호환성: 모든 ERC-20 지갑·거래소·DApp에서 동일하게 동작한다

---

## ERC-20 표준 인터페이스

```solidity
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

### 주요 특징

- **함수(Function)**: 공급량 조회, 잔액 조회, 토큰 전송, 권한 관리
- **이벤트(Event)**: `Transfer`, `Approval` → 블록체인 로그에 기록되어 외부에서 추적 가능

---

## ERC-20 기본 구현

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract ERC20 is IERC20 {
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
}
```

---

## 상태 변수 설명

```solidity
uint256 public totalSupply;
mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;
string public name;
string public symbol;
uint8 public decimals;
```

- **totalSupply** : 전체 발행된 토큰 수량
- **balanceOf** : 각 계정의 잔액
- **allowance** : (owner → spender) 승인된 전송 한도
- **name** : 토큰 이름 (예: MyToken)
- **symbol** : 심볼 (예: MTK, ETH, USDT)
- **decimals** : 소수점 자리수 (보통 18, ETH와 동일)

---

## 생성자

```solidity
constructor(string memory _name, string memory _symbol, uint8 _decimals) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
}
```

- 배포 시 토큰 이름, 심볼, 소수점 자리수를 초기화한다
- 예: `ERC20("MyToken", "MTK", 18)`

---

## 주요 함수 상세

### 1. transfer()

```solidity
function transfer(address recipient, uint256 amount) external returns (bool)
```

- 호출자의 잔액에서 `amount` 차감 → `recipient`에게 추가
- `Transfer` 이벤트 발생
- 토큰 직접 전송

---

### 2. approve()

```solidity
function approve(address spender, uint256 amount) external returns (bool)
```

- `spender` 주소가 `msg.sender` 대신 특정 토큰을 전송할 수 있도록 권한 부여
- `allowance[msg.sender][spender] = amount`
- `Approval` 이벤트 발생

---

### 3. transferFrom()

```solidity
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)
```

- 사전에 `approve`로 설정된 권한만큼 `sender`의 토큰을 `recipient`에게 전송
- 주로 **거래소, DEX, 자동화된 스마트 컨트랙트**가 사용자 대신 토큰을 옮길 때 사용
- `allowance` 감소 후 전송 진행

---

### 4. _mint() (internal)

```solidity
function _mint(address to, uint256 amount) internal
```

- 새로운 토큰 발행
- `totalSupply` 증가, `to`의 잔액 증가
- `Transfer(address(0), to, amount)` 이벤트 발생
- `address(0)`은 “토큰 발행 원점(없던 곳에서 생김)”을 의미한다

---

### 5. _burn() (internal)

```solidity
function _burn(address from, uint256 amount) internal
```

- 특정 계정의 토큰 소각
- `totalSupply` 감소, `from` 잔액 감소
- `Transfer(from, address(0), amount)` 이벤트 발생

---

### 6. mint() / burn() (external)

- 외부에서 토큰 발행·소각을 호출할 수 있게 하는 함수
- **주의**: 현재 코드에서는 누구나 호출 가능하다 → 치명적 보안 문제
- 일반적으로 `onlyOwner` 같은 접근제어(Access Control)를 추가해야 한다

---

## 보안 및 실무 고려사항

- **민트/번 함수 제한**
    - 관리자만 실행 가능해야 한다
    - OpenZeppelin의 `Ownable` 또는 `AccessControl` 활용
- **언더플로/오버플로 안전성**
    - Solidity 0.8.x부터 자동 검사되지만, 구버전에서는 `SafeMath` 필요
- **approve의 이슈**
    - 기존 allowance 변경 시 double-spend 취약점 가능 → 보통 `increaseAllowance`, `decreaseAllowance` 함수로 대체한다
- **이벤트 중요성**
    - `Transfer`, `Approval` 이벤트는 모든 지갑/거래소가 토큰 변동을 추적하는 기반

---

## 요약

- ERC-20은 **가장 널리 쓰이는 토큰 표준**으로 모든 Fungible Token의 기반이다
- 필수 함수: `totalSupply`, `balanceOf`, `transfer`, `allowance`, `approve`, `transferFrom`
- 확장 함수: `mint`, `burn`, 접근제어 추가
- OpenZeppelin의 ERC-20 구현을 사용하는 것이 일반적이며, 보안과 기능이 검증되어 있다